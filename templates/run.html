<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>IG Carousel Run</title>
  <link rel="stylesheet" href="/static/style.css" />
</head>
<body>
  <div class="bg-orb orb-1"></div>
  <div class="bg-orb orb-2"></div>

  <main class="shell">
    <header class="hero">
      <div class="badge">Run {{ run_id }}</div>
      <h1>Generating carousel…</h1>
      <p>Status updates will appear below.</p>
    </header>

    {% if intent %}
    <section class="panel intent-display">
      <h3 class="intent-label">Your Intent:</h3>
      <p class="intent-text">{{ intent }}</p>
      {% if allow_external %}
      <span class="intent-badge">✓ External search enabled</span>
      {% endif %}
    </section>
    {% endif %}

    <section class="panel">
      <div class="status" id="status">Status: {{ status }}</div>
      <div class="spinner" id="spinner"></div>
      <ul class="log" id="log">
        {% for line in logs %}
          <li>{{ line }}</li>
        {% endfor %}
      </ul>
    </section>

    <section class="panel results" id="results" style="display:none;">
      <div class="results-header">
        <h2>Outputs</h2>
        <div style="display: flex; gap: 12px; align-items: center;">
          <a class="button-secondary" id="editAgainBtn" href="#">✏️ Edit & Re-Generate</a>
          <a class="download" id="downloadLink" href="#">Download ZIP</a>
        </div>
      </div>
      <div class="grid" id="grid"></div>
    </section>

    <footer class="foot">
      <span>Keep this tab open while the run completes.</span>
    </footer>
  </main>

  <div class="lightbox" id="lightbox" aria-hidden="true">
    <button class="lightbox-close" type="button" aria-label="Close preview">✕</button>
    <button class="lightbox-nav lightbox-prev" type="button" aria-label="Previous image">‹</button>
    <button class="lightbox-nav lightbox-next" type="button" aria-label="Next image">›</button>
    <img class="lightbox-img" id="lightboxImg" alt="Expanded preview" />
    <div class="lightbox-counter" id="lightboxCounter"></div>
    <button class="lightbox-edit" id="lightboxEdit" type="button">Edit Text</button>
  </div>

  <div class="editor-modal" id="editorModal" aria-hidden="true">
    <div class="editor-container">
      <div class="editor-header">
        <h2>Adjust Text Position</h2>
        <p class="editor-hint">Drag text to move. Drag corner handles or use +/- to resize (Shift for larger steps). Double-click to edit text.</p>
        <button class="editor-close" id="editorClose" type="button">✕</button>
      </div>
      <div class="editor-canvas-wrapper" id="editorCanvasWrapper">
        <canvas id="editorCanvas"></canvas>
        <div id="editorOverlays"></div>
      </div>
      <div class="editor-footer">
        <button class="button-secondary" id="editorCancel">Cancel</button>
        <button class="button-primary" id="editorSave">Save & Re-render</button>
      </div>
    </div>
  </div>

  <script>
    const runId = "{{ run_id }}";
    const statusEl = document.getElementById("status");
    const logEl = document.getElementById("log");
    const resultsEl = document.getElementById("results");
    const gridEl = document.getElementById("grid");
    const spinner = document.getElementById("spinner");
    const downloadLink = document.getElementById("downloadLink");

    const lightbox = document.getElementById("lightbox");
    const lightboxImg = document.getElementById("lightboxImg");
    const closeBtn = document.querySelector(".lightbox-close");
    const prevBtn = document.querySelector(".lightbox-prev");
    const nextBtn = document.querySelector(".lightbox-next");
    const counterEl = document.getElementById("lightboxCounter");

    let currentImages = [];
    let currentIndex = 0;
    let lastOutputsKey = "";
    let lastLogsKey = "";
    let pollTimer = null;

    function renderGrid(outputs) {
      gridEl.innerHTML = "";
      currentImages = outputs.map(name => `/runs/${runId}/${name}`);

      outputs.forEach((name, idx) => {
        const figure = document.createElement("figure");
        figure.className = "card";

        const btn = document.createElement("button");
        btn.className = "zoom";
        btn.type = "button";
        btn.dataset.index = idx;

        const img = document.createElement("img");
        img.src = `/runs/${runId}/${name}`;
        img.alt = name;

        const caption = document.createElement("figcaption");
        caption.textContent = name;

        btn.appendChild(img);
        figure.appendChild(btn);
        figure.appendChild(caption);
        gridEl.appendChild(figure);

        btn.addEventListener("click", () => {
          openLightbox(idx);
        });
      });
    }

    function openLightbox(index) {
      currentIndex = index;
      updateLightbox();
      lightbox.classList.add("open");
      lightbox.setAttribute("aria-hidden", "false");
    }

    function updateLightbox() {
      lightboxImg.src = currentImages[currentIndex];
      counterEl.textContent = `${currentIndex + 1} / ${currentImages.length}`;
      prevBtn.disabled = currentIndex === 0;
      nextBtn.disabled = currentIndex === currentImages.length - 1;
    }

    function navigate(direction) {
      const newIndex = currentIndex + direction;
      if (newIndex >= 0 && newIndex < currentImages.length) {
        currentIndex = newIndex;
        updateLightbox();
      }
    }

    function closeLightbox() {
      lightbox.classList.remove("open");
      lightbox.setAttribute("aria-hidden", "true");
      lightboxImg.src = "";
    }

    closeBtn.addEventListener("click", closeLightbox);
    prevBtn.addEventListener("click", () => navigate(-1));
    nextBtn.addEventListener("click", () => navigate(1));

    lightbox.addEventListener("click", (e) => {
      if (e.target === lightbox) closeLightbox();
    });

    document.addEventListener("keydown", (e) => {
      if (!lightbox.classList.contains("open")) return;
      if (e.key === "Escape") closeLightbox();
      if (e.key === "ArrowLeft") navigate(-1);
      if (e.key === "ArrowRight") navigate(1);
    });

    // Editor functionality
    const editBtn = document.getElementById("lightboxEdit");
    const editorModal = document.getElementById("editorModal");
    const editorClose = document.getElementById("editorClose");
    const editorCancel = document.getElementById("editorCancel");
    const editorSave = document.getElementById("editorSave");
    const editorCanvas = document.getElementById("editorCanvas");
    const editorOverlays = document.getElementById("editorOverlays");
    const editorCanvasWrapper = document.getElementById("editorCanvasWrapper");
    const ctx = editorCanvas.getContext("2d");

    let currentSlideNum = 0;
    let textElements = [];
    let editorScale = 1;
    let editorScaleX = 1;
    let editorScaleY = 1;
    const slideWidth = 1080;
    const slideHeight = 1350;
    const slideAspect = slideWidth / slideHeight;

    editBtn.addEventListener("click", () => {
      currentSlideNum = currentIndex + 1;
      openEditor();
    });

    async function openEditor() {
      const config = await fetchSlideConfig(currentSlideNum);
      const editorImageUrl = config?.editor_bg_url || config?.photo_url || currentImages[currentIndex];
      const usePreCroppedEditorBg = !!config?.editor_bg_url;
      const centering = Array.isArray(config?.centering) && config.centering.length === 2
        ? config.centering
        : [0.5, 0.35];

      const img = new Image();
      img.crossOrigin = "anonymous";
      img.src = editorImageUrl;
      img.onload = () => {
        // Calculate scale to fit in viewport while maintaining aspect ratio
        const maxW = Math.min(window.innerWidth * 0.75, 900);
        const maxH = window.innerHeight * 0.65;

        let displayW, displayH;
        // Always keep editor canvas at generated slide ratio (1080x1350)
        if (maxW / maxH > slideAspect) {
          // Height constrained
          displayH = maxH;
          displayW = displayH * slideAspect;
        } else {
          // Width constrained
          displayW = maxW;
          displayH = displayW / slideAspect;
        }

        // Use integer canvas dimensions to avoid mapping drift.
        displayW = Math.round(displayW);
        displayH = Math.round(displayH);

        editorCanvas.width = displayW;
        editorCanvas.height = displayH;
        editorScaleX = editorCanvas.width / slideWidth;
        editorScaleY = editorCanvas.height / slideHeight;
        editorScale = (editorScaleX + editorScaleY) * 0.5;

        // Draw image. Prefer server-side pre-cropped editor background for exact parity.
        ctx.clearRect(0, 0, editorCanvas.width, editorCanvas.height);
        if (usePreCroppedEditorBg) {
          ctx.drawImage(img, 0, 0, editorCanvas.width, editorCanvas.height);
        } else {
          const sourceW = img.width;
          const sourceH = img.height;
          const sourceAspect = sourceW / sourceH;
          let cropX = 0;
          let cropY = 0;
          let cropW = sourceW;
          let cropH = sourceH;

          const centerX = Math.max(0, Math.min(1, centering[0]));
          const centerY = Math.max(0, Math.min(1, centering[1]));

          if (sourceAspect > slideAspect) {
            // Source is wider: crop left/right.
            cropW = sourceH * slideAspect;
            cropX = (sourceW - cropW) * centerX;
            cropX = Math.max(0, Math.min(sourceW - cropW, cropX));
          } else if (sourceAspect < slideAspect) {
            // Source is taller: crop top/bottom.
            cropH = sourceW / slideAspect;
            cropY = (sourceH - cropH) * centerY;
            cropY = Math.max(0, Math.min(sourceH - cropH, cropY));
          }

          ctx.drawImage(
            img,
            cropX,
            cropY,
            cropW,
            cropH,
            0,
            0,
            editorCanvas.width,
            editorCanvas.height
          );
        }
        editorOverlays.classList.add("raw-preview");

        // Show modal first so we can get canvas position
        editorModal.classList.add("open");
        editorModal.setAttribute("aria-hidden", "false");

        // Wait for layout, then position overlays
        requestAnimationFrame(async () => {
          updateOverlayPosition();
          const overlayW = editorOverlays.clientWidth || editorCanvas.width;
          const overlayH = editorOverlays.clientHeight || editorCanvas.height;
          editorScaleX = overlayW / slideWidth;
          editorScaleY = overlayH / slideHeight;
          editorScale = (editorScaleX + editorScaleY) * 0.5;
          await ensureEditorFontsLoaded();
          createDraggableElements(config);
        });
      };

      img.onerror = () => {
        alert("Failed to load editable source image for this slide.");
      };
    }

    function updateOverlayPosition() {
      // Position overlay container to match canvas exactly in wrapper coordinates.
      // Using offset/client sizes avoids viewport-rect rounding drift.
      editorOverlays.style.top = `${editorCanvas.offsetTop}px`;
      editorOverlays.style.left = `${editorCanvas.offsetLeft}px`;
      editorOverlays.style.width = `${editorCanvas.clientWidth}px`;
      editorOverlays.style.height = `${editorCanvas.clientHeight}px`;
    }

    function closeEditor() {
      editorModal.classList.remove("open");
      editorModal.setAttribute("aria-hidden", "true");
      editorOverlays.classList.remove("raw-preview");
      editorOverlays.innerHTML = "";
      textElements = [];
    }

    async function fetchSlideConfig(slideNum) {
      // Fetch the run config to get text positions
      const res = await fetch(`/api/slide-config/${runId}/${slideNum}`);
      if (!res.ok) return null;
      return await res.json();
    }

    async function ensureEditorFontsLoaded() {
      if (!document.fonts || !document.fonts.load) return;
      const titlePx = Math.max(24, Math.round(120 * editorScale));
      const kickerPx = Math.max(14, Math.round(48 * editorScale));
      const bodyPx = Math.max(14, Math.round(34 * editorScale));
      await Promise.allSettled([
        document.fonts.load(`700 ${titlePx}px "JLeagueKickTitle"`),
        document.fonts.load(`700 ${kickerPx}px "JLeagueKickKicker"`),
        document.fonts.load(`400 ${bodyPx}px "Helvetica Neue"`),
      ]);
    }

    let selectedElement = null;

    function createDraggableElements(config) {
      if (!config) return;

      textElements = [];
      editorOverlays.innerHTML = "";
      selectedElement = null;
      const scales = config.scales || {};

      // Add kicker, title, body as draggable elements
      // Position them based on centering values
      if (config.kicker) {
        createDraggable("kicker", config.kicker, config.kicker_pos, scales.kicker || 1);
      }
      createDraggable("title", config.title, config.title_pos, scales.title || 1);
      if (config.body) {
        createDraggable("body", config.body, config.body_pos, scales.body || 1);
      }
    }

    function applyTextScale(wrapper, textEl, type, scale) {
      const clamped = Math.max(0.5, Math.min(3.0, scale));
      wrapper.dataset.scale = String(clamped);
      const baseSize = type === "title" ? 120 : (type === "kicker" ? 48 : 34);
      const previewScale = editorScaleX || editorScale;
      if (editorOverlays.classList.contains("raw-preview")) {
        textEl.style.fontSize = `${baseSize * clamped * previewScale}px`;
        textEl.style.width = `${(slideWidth - 120) * previewScale}px`; // 1080 - margins (60*2)
        textEl.style.textAlign = "center";
      } else {
        const fallbackBase = type === "title" ? 24 : (type === "kicker" ? 14 : 16);
        textEl.style.fontSize = `${fallbackBase * clamped}px`;
      }
    }

    function createDraggable(type, text, pos, initialScale = 1) {
      const wrapper = document.createElement("div");
      wrapper.className = `draggable-text draggable-${type}`;

      // Convert from original 1080x1350 coords to scaled coords
      const scaledX = pos.x * editorScaleX;
      const scaledY = pos.y * editorScaleY;

      wrapper.style.left = scaledX + "px";
      wrapper.style.top = scaledY + "px";
      wrapper.style.transform = "translate(-50%, -50%)"; // Center on position

      // Type label (shows on hover)
      const typeLabel = document.createElement("div");
      typeLabel.className = "type-label";
      typeLabel.textContent = type;

      // Text content
      const textEl = document.createElement("div");
      textEl.className = "text-content";
      textEl.contentEditable = "false";
      textEl.textContent = text;
      textEl.dataset.originalText = text;
      wrapper.dataset.originalScale = String(initialScale);
      applyTextScale(wrapper, textEl, type, initialScale);

      // Resize handles
      const handles = ['nw', 'ne', 'sw', 'se'].map(corner => {
        const handle = document.createElement("div");
        handle.className = `resize-handle ${corner}`;
        handle.dataset.corner = corner;
        return handle;
      });

      wrapper.appendChild(typeLabel);
      wrapper.appendChild(textEl);
      handles.forEach(h => wrapper.appendChild(h));

      let isDragging = false;
      let isResizing = false;
      let isEditing = false;
      let startX, startY, initialX, initialY;
      let resizeCorner = "se";
      let startScale = initialScale;
      let resizeAnchorX = 0;
      let resizeAnchorY = 0;

      function anchorFromCorner(corner, cx, cy, w, h) {
        switch (corner) {
          case "se":
            return { x: cx - w / 2, y: cy - h / 2 }; // keep NW fixed
          case "ne":
            return { x: cx - w / 2, y: cy + h / 2 }; // keep SW fixed
          case "sw":
            return { x: cx + w / 2, y: cy - h / 2 }; // keep NE fixed
          case "nw":
            return { x: cx + w / 2, y: cy + h / 2 }; // keep SE fixed
          default:
            return { x: cx - w / 2, y: cy - h / 2 };
        }
      }

      function centerFromAnchor(corner, anchorX, anchorY, w, h) {
        switch (corner) {
          case "se":
            return { x: anchorX + w / 2, y: anchorY + h / 2 };
          case "ne":
            return { x: anchorX + w / 2, y: anchorY - h / 2 };
          case "sw":
            return { x: anchorX - w / 2, y: anchorY + h / 2 };
          case "nw":
            return { x: anchorX - w / 2, y: anchorY - h / 2 };
          default:
            return { x: anchorX + w / 2, y: anchorY + h / 2 };
        }
      }

      handles.forEach(handle => {
        handle.addEventListener("mousedown", (e) => {
          if (isEditing) return;
          e.preventDefault();
          e.stopPropagation();
          selectElement(wrapper);
          isResizing = true;
          resizeCorner = handle.dataset.corner || "se";
          startX = e.clientX;
          startY = e.clientY;
          startScale = parseFloat(wrapper.dataset.scale || "1");
          const cx = parseFloat(wrapper.style.left);
          const cy = parseFloat(wrapper.style.top);
          const w = wrapper.offsetWidth;
          const h = wrapper.offsetHeight;
          const anchor = anchorFromCorner(resizeCorner, cx, cy, w, h);
          resizeAnchorX = anchor.x;
          resizeAnchorY = anchor.y;
          wrapper.classList.add("dragging");
          document.body.style.userSelect = "none";
          document.body.style.cursor = "nwse-resize";
        });
      });

      // Click to select, then drag
      wrapper.addEventListener("mousedown", (e) => {
        if (isEditing) return;
        if (e.target.classList.contains("resize-handle")) return;

        e.preventDefault();
        e.stopPropagation();

        // Select this element
        selectElement(wrapper);

        // Start dragging
        isDragging = true;
        startX = e.clientX;
        startY = e.clientY;

        const rect = wrapper.getBoundingClientRect();
        const overlayRect = editorOverlays.getBoundingClientRect();
        initialX = rect.left + rect.width/2 - overlayRect.left;
        initialY = rect.top + rect.height/2 - overlayRect.top;

        wrapper.classList.add("dragging");
        document.body.style.userSelect = "none";
        document.body.style.cursor = "grabbing";
      });

      const onMouseMove = (e) => {
        if (isResizing) {
          const dx = e.clientX - startX;
          const dy = e.clientY - startY;
          const dirX = resizeCorner.includes("e") ? 1 : -1;
          const dirY = resizeCorner.includes("s") ? 1 : -1;
          const delta = (dx * dirX + dy * dirY) / 260;
          applyTextScale(wrapper, textEl, type, startScale * (1 + delta));
          const newW = wrapper.offsetWidth;
          const newH = wrapper.offsetHeight;
          const center = centerFromAnchor(resizeCorner, resizeAnchorX, resizeAnchorY, newW, newH);
          wrapper.style.left = `${center.x}px`;
          wrapper.style.top = `${center.y}px`;
          return;
        }
        if (!isDragging) return;
        const dx = e.clientX - startX;
        const dy = e.clientY - startY;

        wrapper.style.left = (initialX + dx) + "px";
        wrapper.style.top = (initialY + dy) + "px";
      };

      const onMouseUp = () => {
        if (isResizing) {
          wrapper.classList.remove("dragging");
          isResizing = false;
          document.body.style.userSelect = "";
          document.body.style.cursor = "";
          return;
        }
        if (isDragging) {
          wrapper.classList.remove("dragging");
          isDragging = false;
          document.body.style.userSelect = "";
          document.body.style.cursor = "";
        }
      };

      document.addEventListener("mousemove", onMouseMove);
      document.addEventListener("mouseup", onMouseUp);

      // Double-click to edit text
      wrapper.addEventListener("dblclick", (e) => {
        e.preventDefault();
        e.stopPropagation();

        isEditing = true;
        wrapper.classList.add("editing");
        textEl.contentEditable = "true";
        textEl.focus();

        // Select all text
        const range = document.createRange();
        range.selectNodeContents(textEl);
        const sel = window.getSelection();
        sel.removeAllRanges();
        sel.addRange(range);
      });

      // Exit edit mode on blur
      textEl.addEventListener("blur", () => {
        isEditing = false;
        wrapper.classList.remove("editing");
        textEl.contentEditable = "false";
      });

      // Handle Enter key to exit editing
      textEl.addEventListener("keydown", (e) => {
        if (e.key === "Enter" && !e.shiftKey) {
          e.preventDefault();
          textEl.blur();
        }
        if (e.key === "Escape") {
          textEl.textContent = textEl.dataset.originalText;
          textEl.blur();
        }
      });

      editorOverlays.appendChild(wrapper);
      textElements.push({ type, element: wrapper, textElement: textEl });
    }

    function getRecordForElement(wrapper) {
      return textElements.find(te => te.element === wrapper) || null;
    }

    function selectElement(wrapper) {
      // Deselect previous
      if (selectedElement && selectedElement !== wrapper) {
        selectedElement.classList.remove("selected");
      }
      // Select new
      wrapper.classList.add("selected");
      selectedElement = wrapper;
    }

    // Click on canvas (not on element) to deselect
    editorCanvas.addEventListener("click", () => {
      if (selectedElement) {
        selectedElement.classList.remove("selected");
        selectedElement = null;
      }
    });

    // Keyboard controls for selected element
    document.addEventListener("keydown", (e) => {
      if (!editorModal.classList.contains("open")) return;
      if (!selectedElement) return;

      // Don't handle keys if editing text
      const isEditing = selectedElement.classList.contains("editing");
      if (isEditing) return;

      const nudgeAmount = e.shiftKey ? 10 : 1; // Shift for larger nudge

      switch(e.key) {
        case "ArrowUp":
          e.preventDefault();
          selectedElement.style.top = (parseFloat(selectedElement.style.top) - nudgeAmount) + "px";
          break;
        case "ArrowDown":
          e.preventDefault();
          selectedElement.style.top = (parseFloat(selectedElement.style.top) + nudgeAmount) + "px";
          break;
        case "ArrowLeft":
          e.preventDefault();
          selectedElement.style.left = (parseFloat(selectedElement.style.left) - nudgeAmount) + "px";
          break;
        case "ArrowRight":
          e.preventDefault();
          selectedElement.style.left = (parseFloat(selectedElement.style.left) + nudgeAmount) + "px";
          break;
        case "+":
        case "=":
          e.preventDefault();
          {
            const record = getRecordForElement(selectedElement);
            if (record) {
              const cur = parseFloat(selectedElement.dataset.scale || "1");
              applyTextScale(selectedElement, record.textElement, record.type, cur * (e.shiftKey ? 1.2 : 1.08));
            }
          }
          break;
        case "-":
        case "_":
          e.preventDefault();
          {
            const record = getRecordForElement(selectedElement);
            if (record) {
              const cur = parseFloat(selectedElement.dataset.scale || "1");
              applyTextScale(selectedElement, record.textElement, record.type, cur / (e.shiftKey ? 1.2 : 1.08));
            }
          }
          break;
        case "Escape":
          selectedElement.classList.remove("selected");
          selectedElement = null;
          break;
      }
    });

    editorClose.addEventListener("click", closeEditor);
    editorCancel.addEventListener("click", closeEditor);

    // Handle window resize
    window.addEventListener("resize", () => {
      if (editorModal.classList.contains("open")) {
        updateOverlayPosition();
      }
    });

    editorSave.addEventListener("click", async () => {
      editorSave.disabled = true;
      editorSave.textContent = "Saving...";

      // Collect new positions - convert back to original 1080x1350 coords
      const positions = textElements.map(te => {
        const left = parseFloat(te.element.style.left);
        const top = parseFloat(te.element.style.top);

        return {
          type: te.type,
          x: left / editorScaleX,
          y: top / editorScaleY
        };
      });

      // Collect text updates
      const textUpdates = {};
      const sizeUpdates = {};
      textElements.forEach(te => {
        const newText = te.textElement.textContent.trim();
        const originalText = te.textElement.dataset.originalText;
        if (newText !== originalText) {
          textUpdates[te.type] = newText;
        }
        const currentScale = parseFloat(te.element.dataset.scale || "1");
        const originalScale = parseFloat(te.element.dataset.originalScale || "1");
        if (Math.abs(currentScale - originalScale) > 0.01) {
          sizeUpdates[te.type] = currentScale;
        }
      });

      try {
        // Send to server to re-render
        const res = await fetch(`/api/update-slide/${runId}/${currentSlideNum}`, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            positions,
            text_updates: Object.keys(textUpdates).length > 0 ? textUpdates : null,
            size_updates: Object.keys(sizeUpdates).length > 0 ? sizeUpdates : null
          })
        });

        if (res.ok) {
          closeEditor();
          closeLightbox();
          // Refresh images
          location.reload();
        } else {
          const error = await res.json();
          alert("Failed to save changes: " + (error.detail || "Unknown error"));
        }
      } catch (err) {
        alert("Failed to save changes: " + err.message);
      } finally {
        editorSave.disabled = false;
        editorSave.textContent = "Save & Re-render";
      }
    });

    async function poll() {
      const res = await fetch(`/api/status/${runId}`);
      if (!res.ok) return;
      const data = await res.json();
      statusEl.textContent = `Status: ${data.status}`;
      const logs = data.logs || [];
      const logsKey = logs.join("\n");
      if (logsKey !== lastLogsKey) {
        lastLogsKey = logsKey;
        logEl.innerHTML = "";
        logs.forEach((line) => {
          const li = document.createElement("li");
          li.textContent = line;
          logEl.appendChild(li);
        });
      }

      // Redirect to preview page if awaiting approval
      if (data.status === "awaiting_approval") {
        window.location.href = `/run/${runId}/preview`;
        return;
      }

      if (data.status === "done") {
        spinner.style.display = "none";
        resultsEl.style.display = "block";
        downloadLink.href = data.download_url;
        const outputs = data.outputs || [];
        const outputsKey = outputs.join("|");
        if (outputsKey !== lastOutputsKey) {
          lastOutputsKey = outputsKey;
          renderGrid(outputs);
        }

        // Enable edit button
        const editBtn = document.getElementById("editAgainBtn");
        if (editBtn) {
          editBtn.href = `/run/${runId}/preview`;
        }

        // Stop polling once final outputs are rendered to prevent visual flicker.
        if (pollTimer) {
          clearInterval(pollTimer);
          pollTimer = null;
        }
      }

      if (data.status === "error") {
        spinner.style.display = "none";
        if (pollTimer) {
          clearInterval(pollTimer);
          pollTimer = null;
        }
      }
    }

    poll();
    pollTimer = setInterval(poll, 2000);
  </script>
</body>
</html>
